#pragma once

#include <cstdint>
#include <string>
#include <vector>

#include "ai/learning/bandit.h"

namespace chronosdb {
namespace ai {

/**
 * Execution optimization strategies that the Learning Engine can recommend.
 * Each dimension represents an independent decision the optimizer makes.
 */

// Filter evaluation order strategy
enum class FilterStrategy : uint8_t {
    ORIGINAL_ORDER = 0,     // Evaluate WHERE conditions in parse order
    SELECTIVITY_ORDER = 1,  // Most selective (filters most rows) first
    COST_ORDER = 2          // Cheapest conditions (= before LIKE) first
};

// Projection strategy
enum class ProjectionStrategy : uint8_t {
    LATE_MATERIALIZATION = 0,   // Read all columns, project at end (current behavior)
    EARLY_MATERIALIZATION = 1   // Read only needed columns during scan
};

// Limit optimization strategy
enum class LimitStrategy : uint8_t {
    FULL_SCAN_THEN_LIMIT = 0,   // Scan all, then truncate (current behavior)
    EARLY_TERMINATION = 1        // Stop scanning after limit reached
};

/**
 * ExecutionPlan - A complete set of optimization decisions for a SELECT query.
 *
 * Generated by the Learning Engine based on learned performance patterns.
 * The DMLExecutor follows this plan to execute the query optimally.
 */
struct ExecutionPlan {
    // Scan layer
    ScanStrategy scan_strategy = ScanStrategy::SEQUENTIAL_SCAN;

    // Filter layer: reordered WHERE condition indices
    FilterStrategy filter_strategy = FilterStrategy::ORIGINAL_ORDER;
    std::vector<size_t> filter_order;  // Indices into stmt->where_clause_

    // Projection layer
    ProjectionStrategy projection_strategy = ProjectionStrategy::LATE_MATERIALIZATION;

    // Limit optimization
    LimitStrategy limit_strategy = LimitStrategy::FULL_SCAN_THEN_LIMIT;

    // Whether AI generated this plan (vs. default fallback)
    bool ai_generated = false;

    std::string ToString() const;
};

/**
 * ExecutionFeedback - Rich feedback recorded after query execution.
 *
 * Used by the Learning Engine to update its models about which
 * strategies work best for which query shapes.
 */
struct ExecutionFeedback {
    std::string table_name;
    uint64_t duration_us = 0;
    uint32_t total_rows_scanned = 0;
    uint32_t rows_after_filter = 0;
    uint32_t result_rows = 0;
    bool used_index = false;
    size_t where_clause_count = 0;
    bool had_limit = false;
    int32_t limit_value = -1;
    bool had_order_by = false;

    // The plan that was used
    ExecutionPlan plan_used;
};

} // namespace ai
} // namespace chronosdb
